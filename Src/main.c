/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stm32f407xx.h>
#include "gpio_drv.h"
#include "gpio_exti_drv.h"
#include "spi_drv.h"
#include "i2c_drv.h"
#include "usart_drv.h"

/* MACROs */
#define GPIO_EN  1
#define EXTI_EN  1
#define SPI_EN   0
#define I2C_EN   0
#define USART_EN 1

/* VARIABLEs */

#if GPIO_EN
GPIO_Handle_t green_led_pin;
#endif

#if EXTI_EN
GPIO_EXTI_Handle_t user_btn_pin, falling_edge_trig_test;
#endif

#if SPI_EN
GPIO_Handle_t spi2_miso, spi2_mosi, spi2_sclk, spi2_nss;
SPI_Handle_t spi2_handle;
uint8_t spi_irq_event;
uint8_t spi_receiving_data[32];
#endif

#if I2C_EN
GPIO_Handle_t i2c_scl, i2c_data;
I2C_Handle_t i2c_handle;
#endif

#if USART_EN
GPIO_Handle_t usart2_tx, usart2_rx;
USART_Handle_t usart_handle;
uint8_t usart_receiving_data[32];
#endif

#if EXTI_EN
void toggleLed(void)
{
	gpio_drv_Toggle(&green_led_pin);
}
#endif

#if SPI_EN
void spiIRQEvent(void *self, uint8_t event)
{
	spi_irq_event = event;
}
#endif

#if I2C_EN
uint8_t i2c_recieved_byte_size;
uint8_t i2c_recieved_buff[32];

void i2cIRQEvent(void *self, uint8_t event)
{
	if (_I2C_IRQ_EVENT_DATA_REQ == event)
	{
		i2c_drv_SlaveSendData(&i2c_handle, 10);
		i2c_recieved_byte_size = 0;
	}

	if (_I2C_IRQ_EVENT_DATA_RCV == event)
	{
		i2c_recieved_buff[i2c_recieved_byte_size++] = i2c_drv_SlaveReceiveData(&i2c_handle);
	}
}
#endif

#if USART_EN

void usartIRQEvent(void *self, uint8_t event)
{
	if (_USART_IRQ_EVENT_RX_CMPLT == event)
	{
		if ((0xFF == usart_receiving_data[0]) && (0xFE == usart_receiving_data[1]))
			usart_drv_ReceiveDataIT(&usart_handle, usart_receiving_data, usart_receiving_data[2]);
	}
	if (_USART_IRQ_EVENT_TX_CMPLT == event)
	{
		usart_drv_ReceiveDataIT(&usart_handle, usart_receiving_data, 3);
	}
}

#endif

int main(void)
{
	#if GPIO_EN
	/* Green Led Output Pin */
	gpio_drv_PeripheralClockControl(GPIOD, true);
	gpio_drv_Init(&green_led_pin, GPIOD, 12, _GPIO_PIN_MODE_OUTPUT, _GPIO_PIN_OUTPUT_PUSH_PULL,
		_GPIO_PIN_OUTPUT_LOW_SPEED, _GPIO_PIN_NO_PULL_UP_PULL_DOWN, 0);
	#endif

	#if EXTI_EN
	/* User Button Init Pin As EXTI */
	gpio_drv_PeripheralClockControl(GPIOA, true);
	gpio_drv_PeripheralClockControl(GPIOC, true);

	gpio_exti_drv_Init(&user_btn_pin, GPIOA, 0, _GPIO_PIN_PULL_DOWN, _GPIO_EXTI_PIN_TRIG_RISING_EDGE, 4, toggleLed);
	gpio_exti_drv_Init(&falling_edge_trig_test, GPIOC, 6, _GPIO_PIN_PULL_UP, _GPIO_EXTI_PIN_TRIG_FALLING_EDGE, 1, NULL);
	#endif

	#if SPI_EN
	/* SPI Pins Init */
	/* Alt func mode 5
	 * PB13 --> SPI2_SCLK
	 * PB15 --> SPI2_MOSI
	 * PB14 --> SPI2_MISO
	 * PB12 --> SPI2_NSS
	 * */
	gpio_drv_PeripheralClockControl(GPIOB, true);

	gpio_drv_Init(&spi2_sclk, GPIOB, 13, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_PUSH_PULL,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_NO_PULL_UP_PULL_DOWN, _GPIO_PIN_ALT_FUNC_5);

	gpio_drv_Init(&spi2_mosi, GPIOB, 15, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_PUSH_PULL,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_NO_PULL_UP_PULL_DOWN, _GPIO_PIN_ALT_FUNC_5);

	gpio_drv_Init(&spi2_miso, GPIOB, 14, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_PUSH_PULL,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_NO_PULL_UP_PULL_DOWN, _GPIO_PIN_ALT_FUNC_5);

	gpio_drv_Init(&spi2_nss, GPIOB, 12, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_PUSH_PULL,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_NO_PULL_UP_PULL_DOWN, _GPIO_PIN_ALT_FUNC_5);

	SPI_config_t spi2_config;

	spi2_config.mode = _SPI_DEVICE_MODE_MASTER;
	spi2_config.bus_config = _SPI_BUS_CONFIG_FULL_DULEX;
	spi2_config.speed = _SPI_BUS_SPEED_DIV_32;
	spi2_config.dff = _SPI_DFF_8BITS;
	spi2_config.cpha = _SPI_CPHA_LOW;
	spi2_config.cpol = _SPI_CPOL_LOW;
	spi2_config.ssm = _SPI_SSM_HW;
	spi2_config.first_bit = _SPI_FF_MSB_FIRST;

	spi_drv_Init(&spi2_handle, SPI2, spi2_config);

	spi_drv_SetInterrupts(&spi2_handle, 3, spiIRQEvent);

	char spi_hello[] = "Hello, world";

	spi_drv_PeripheralControl(&spi2_handle, true);

	spi_drv_ReceiveDataIT(&spi2_handle, spi_receiving_data, sizeof(spi_receiving_data));

	spi_drv_SendDataIT(&spi2_handle, (uint8_t*)spi_hello, strlen(spi_hello));

	spi_drv_PeripheralControl(&spi2_handle, false);
	#endif

	#if I2C_EN
	/* I2C Pins Init */

	/* Alt func mode 4
	 * PB9 --> I2C1_SDA
	 * PB6 --> I2C1_SCL
	 * */

	gpio_drv_PeripheralClockControl(GPIOB, true);

	gpio_drv_Init(&i2c_scl, GPIOB, 6, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_OPEN_DRAIN,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_NO_PULL_UP_PULL_DOWN, _GPIO_PIN_ALT_FUNC_4);

	gpio_drv_Init(&i2c_data, GPIOB, 9, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_OPEN_DRAIN,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_NO_PULL_UP_PULL_DOWN, _GPIO_PIN_ALT_FUNC_4);


	I2C_config_t i2c1_config;
	i2c1_config.ack_control = _I2C_ACK_ENABLE;
	i2c1_config.device_addr = 0x10;
	i2c1_config.fm_duty_cycle = _I2C_FM_DUTY_CYCLE_2;
	i2c1_config.scl_speed = _I2C_SCL_SPEED_SM;

	i2c_drv_Init(&i2c_handle, I2C1, i2c1_config);
	i2c_drv_SetInterrupts(&i2c_handle, 4, i2cIRQEvent);
	i2c_drv_SlaveInterruptsManagement(&i2c_handle, true);
	#endif


	#if USART_EN
	/* USART Pins Init */

	/* Alt func mode 7
	 * PA2 --> USART2_TX
	 * PA3 --> USART2_RX
	 * */
	gpio_drv_PeripheralClockControl(GPIOA, true);


	gpio_drv_Init(&usart2_tx, GPIOA, 2, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_PUSH_PULL,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_PULL_UP, _GPIO_PIN_ALT_FUNC_7);

	gpio_drv_Init(&usart2_rx, GPIOA, 3, _GPIO_PIN_MODE_ALT_FUNC, _GPIO_PIN_OUTPUT_PUSH_PULL,
		_GPIO_PIN_OUTPUT_VERY_HIGH_SPEED, _GPIO_PIN_PULL_UP, _GPIO_PIN_ALT_FUNC_7);

	USART_config_t usart_config;
	usart_config.mode = _USART_MODE_TX_RX;
	usart_config.baudrate = _USART_STANDART_BR_115200;
	usart_config.nosb = _USART_STOP_BITS_2;
	usart_config.word_length = _USART_WORD_LENGTH_9BITS;
	usart_config.parity_control = _USART_PARITY_CONTROL_EVEN;
	usart_config.hw_flow_control = _USART_HW_FLOW_CONTROL_NONE;
	usart_drv_Init(&usart_handle, USART2, usart_config);

	char usart_sending_data[] = "Hello, there...";

	usart_drv_SetInterrupts(&usart_handle, 5, usartIRQEvent);

	usart_drv_SendDataIT(&usart_handle, (uint8_t*)usart_sending_data, strlen(usart_sending_data));



	#endif

	for(;;)
	{


	}
}

#if EXTI_EN
void EXTI0_IRQHandler(void)
{
	gpio_exti_drv_IRQHandler(&user_btn_pin);
}

void EXTI9_5_IRQHandler(void)
{
	gpio_exti_drv_IRQHandler(&falling_edge_trig_test);
}
#endif

#if SPI_EN
void SPI1_IRQHandler(void)
{
	spi_drv_IRQHandler(&spi2_handle);
}

void SPI2_IRQHandler(void)
{
	spi_drv_IRQHandler(&spi2_handle);
}

void SPI3_IRQHandler(void)
{
	spi_drv_IRQHandler(&spi2_handle);
}
#endif

#if I2C_EN
void I2C1_EV_IRQHandler(void)
{
	i2c_drv_EventIRQHandler(&i2c_handle);
}

void I2C1_ER_IRQHandler(void)
{
	i2c_drv_ErrorIRQHandler(&i2c_handle);
}
#endif

#if USART_EN
void USART2_IRQHandler(void)
{
	usart_drv_IRQHandler(&usart_handle);
}
#endif
